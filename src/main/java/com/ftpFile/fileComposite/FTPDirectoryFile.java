/**
 * 
 */
package com.ftpFile.fileComposite;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import com.util.FTPFileType;
import com.util.UnixTreeCharacter;

/**
 * This class is a representation of a FTP directory. It can contains
 * regular or/and symbolic files or/and directories. This class represents 
 * a composition of the elements of the Composite {@link FTPFileComponent} pattern. 
 * It extends from the FTPFileComponent. 
 * @author idtaleb
 *
 */
public class FTPDirectoryFile extends FTPFileComponent {
	/**
	 * A buffer size multiplier used to build the tree.
	 */
	private static final int SIZE_MULTIPLIER = 20;
	
	/**
	 * Construct a FTP directory with a name and a it's parent. If the parent 
	 * is null so the specified directory will be the parent.
	 * @param dirName The FTP directory name.
	 * @param parentFile The FTP parent file.
	 * @param depth The level of the component.
	 */
	public FTPDirectoryFile(String dirName, FTPDirectoryFile parentFile, int depth) {
		super(dirName,  parentFile, depth);
	}
	
	/**
	 * Check if the file is a directory
	 * @return true if the file is a directory, false if not.
	 */
	public boolean isDirectory() {
		return this.getFileType()==FTPFileType.DIRECTORY_FILE;
	}
	
	/**
	 * Get the number of the directories.
	 * @param dirCmp A counter. must be initialized to 0 when calling this method.
	 * @param files A list of sub files of the current directory.
	 * @return The number of the directories of the current directory.
	 */
	public int getNumberOfDirectories(int dirCmp, List<FTPFileComponent> files) {
		if (this.getFileType() == FTPFileType.DIRECTORY_FILE) {	
			if (files.isEmpty())
				return dirCmp;
			for (FTPFileComponent f : files) 
				dirCmp = 1+this.getNumberOfDirectories(dirCmp, f.getChilds());		
		}
		return dirCmp;
	}
	
	@Override
	protected FTPFileType createFileType() {
		return FTPFileType.DIRECTORY_FILE;
	}
	
	/**
	 * Show directory tree by using the depth-first algorithm. 
	 * @return The hierarchical representation of the directory. 
	 */
	@Override
	protected String _showTree_() {
		List<StringBuilder> lines = _renderDirectoryTreeLines_(this);
	    String newline = UnixTreeCharacter.LINE_SEPERATOR;
	    StringBuilder sb = new StringBuilder(lines.size() * SIZE_MULTIPLIER);
	    for (StringBuilder line : lines) {
	        sb.append(line);
	        sb.append(newline);
	    }
	    return sb.toString() + this.getNumberOfDirectories(0, this.getChilds()) +" directories";
	}
	
	/**
	 * Build the recursive structure of the directory passed as the argument. 
	 * Each level of the tree is considered as a line in the list of string builders.
	 * @param tree An FTP file, could be a directory, regular or symbolic file. 
	 * @return a list of strings that represents each level of the tree.
	 */
	private List<StringBuilder> _renderDirectoryTreeLines_(FTPFileComponent tree) {
	    List<StringBuilder> result = new LinkedList<StringBuilder>();
	    result.add(new StringBuilder().append(tree.getFileName()));
    	Iterator<FTPFileComponent> iterator = tree.getChilds().iterator();
    	while (iterator.hasNext()) {
	        List<StringBuilder> subtree = _renderDirectoryTreeLines_(iterator.next());
	        if (iterator.hasNext()) 
	            _addSubtree_(result, subtree);
	        else 
	            _addLastSubtree_(result, subtree);
	    } 
	    return result;
	}
	
	/**
	 * Explore and builds the subtree which is not the last one.
	 * @param result The result of the build. All the lines are push to the result.
	 * @param subtree The subtree to explore.
	 */
	private void _addSubtree_(List<StringBuilder> result, List<StringBuilder> subtree) {
	    Iterator<StringBuilder> iterator = subtree.iterator();
	    //subtree generated by renderDirectoryTreeLines has at least one line which is tree
	    result.add(iterator.next().insert(0, UnixTreeCharacter.SUBFILE_CHAR));
	    while (iterator.hasNext()) 
	        result.add(iterator.next().insert(0, UnixTreeCharacter.SUBFILE_LEVEL));
	}
	
	/**
	 * Explore and builds the subtree which is the last one.
	 * @param result The result of the build. All the lines are push to the result.
	 * @param subtree The subtree to explore.
	 */
	private void _addLastSubtree_(List<StringBuilder> result, List<StringBuilder> subtree) {
	    Iterator<StringBuilder> iterator = subtree.iterator();
	    result.add(iterator.next().insert(0, UnixTreeCharacter.LAST_SUBFILE_CHAR));
	    while (iterator.hasNext()) 
	        result.add(iterator.next().insert(0, UnixTreeCharacter.LINE_SPACE));
	}
	
	/**
	 * A directory is reachable if it has group execution or other execution rights. 
	 * @return True if the directory is reachable or can be read. False if not.
	 */
	public boolean isAccessibleDirectory() {
		return this.hasGroupExecuteRight() || this.hasOtherExecuteRight();
	}
}
